import{Vector3}from"./vector";class Quaternion{constructor(x,y,z,w){this.x=x||0,this.y=y||0,this.z=z||0,this.w=w||1}set(x,y,z,w){return this.x=x,this.y=y,this.z=z,this.w=w,this}normalize(){const length=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===length?(this.x=this.y=this.z=0,this.w=1):(this.x/=length,this.y/=length,this.z/=length,this.w/=length),this}multiply(quaternion){const x=this.x,y=this.y,z=this.z,w=this.w,qx=quaternion.x,qy=quaternion.y,qz=quaternion.z,qw=quaternion.w;return this.x=x*qw+w*qx+y*qz-z*qy,this.y=y*qw+w*qy+z*qx-x*qz,this.z=z*qw+w*qz+x*qy-y*qx,this.w=w*qw-x*qx-y*qy-z*qz,this}toRotationMatrix(){const matrix=[],x2=this.x+this.x,y2=this.y+this.y,z2=this.z+this.z,xx=this.x*x2,xy=this.x*y2,xz=this.x*z2,yy=this.y*y2,yz=this.y*z2,zz=this.z*z2,wx=this.w*x2,wy=this.w*y2,wz=this.w*z2;return matrix[0]=1-(yy+zz),matrix[1]=xy-wz,matrix[2]=xz+wy,matrix[3]=xy+wz,matrix[4]=1-(xx+zz),matrix[5]=yz-wx,matrix[6]=xz-wy,matrix[7]=yz+wx,matrix[8]=1-(xx+yy),matrix}invert(){const lengthSq=this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;if(lengthSq>0){const invLengthSq=1/lengthSq;this.x*=-invLengthSq,this.y*=-invLengthSq,this.z*=-invLengthSq,this.w*=invLengthSq}return this}toString(){return`(${this.x}, ${this.y}, ${this.z}, ${this.w})`}test(){const quat1=new Quaternion(1,2,3,4);console.assert("(1, 2, 3, 4)"===quat1.toString(),"Constructor or toString failed.");const quat1Clone=quat1.clone();console.assert(quat1Clone.toString()===quat1.toString(),"Clone method failed.");const quat1Inverse=quat1.clone().invert();console.assert(quat1Inverse.toString()!==quat1.toString(),"Invert method failed to change the quaternion.");const vector=new Vector3(1,0,0),angle=Math.PI/2,rotatedVector=new Quaternion(0,Math.sin(angle/2),0,Math.cos(angle/2)).rotateVector(vector);console.assert(rotatedVector.equals(new Vector3(0,0,1)),"rotateVector method failed."),console.log("All Quaternion tests passed!")}}export{Quaternion};