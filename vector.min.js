import{Quaternion}from"./quaternion";class Vector2{constructor(x,y){this.x=x||0,this.y=y||0}clone(){return new Vector2(this.x,this.y)}copy(vector){return this.x=vector.x,this.y=vector.y,this}set(x,y){return this.x=x,this.y=y,this}reset(){return this.x=0,this.y=0,this}scale(scalar,target){return(target=target||new Vector2).x=this.x*scalar,target.y=this.y*scalar,target}add(vector){return this.x+=vector.x,this.y+=vector.y,this}multiply(vector,target){return(target=target||new Vector2).x=vector.x*this.x,target.y=vector.y*this.y,target}lerp(vector,t=.5,target){target=target||new Vector2;const x=this.x,y=this.y;return target.x=x+(vector.x-x)*t,target.y=y+(vector.y-y)*t,target}length(){const x=this.x,y=this.y;return Math.sqrt(x*x+y*y)}lengthSquared(){const x=this.x,y=this.y;return x*x+y*y}distanceTo(o){const x=this.x,y=this.y,ox=o.x,oy=o.y;return Math.sqrt((ox-x)*(ox-x)+(oy-y)*(oy-y))}distanceSquared(o){const x=this.x,y=this.y,ox=o.x,oy=o.y;return(ox-x)*(ox-x)+(oy-y)*(oy-y)}negate(target){return(target=target||new Vector2).x=-this.x,target.y=-this.y,target}toArray(){return[this.x,this.y]}toObject(){return{x:this.x,y:this.y}}toString(){return`(${this.x}, ${this.y})`}normalize(target){target=target||new Vector2;const x=this.x,y=this.y,len=Math.sqrt(x*x+y*y);return len>0&&(target.x=x/len,target.y=y/len),target}random(target){return(target=target||new Vector2).x=Math.random(),target.y=Math.random(),target}}class Vector3{constructor(x,y,z){this.x=x||0,this.y=y||0,this.z=z||0}clone(){return new Vector3(this.x,this.y,this.z)}copy(vector){return this.x=vector.x,this.y=vector.y,this.z=vector.z,this}random(target){return(target=target||new Vector3).x=Math.random(),target.y=Math.random(),target.z=Math.random(),target}set(x,y,z){return this.x=x,this.y=y,this.z=z,this}reset(){return this.x=0,this.y=0,this.z=0,this}length(){const x=this.x,y=this.y,z=this.z;return Math.sqrt(x*x+y*y+z*z)}lengthSquared(){return this.dot(this)}distanceTo(o){const x=this.x,y=this.y,z=this.z,ox=o.x,oy=o.y,oz=o.z;return Math.sqrt((ox-x)*(ox-x)+(oy-y)*(oy-y)+(oz-z)*(oz-z))}distanceSquared(o){const x=this.x,y=this.y,z=this.z,ox=o.x,oy=o.y,oz=o.z;return(ox-x)*(ox-x)+(oy-y)*(oy-y)+(oz-z)*(oz-z)}scale(scalar,target){return(target=target||new Vector3).x=this.x*scalar,target.y=this.y*scalar,target.z=this.z*scalar,target}multiply(vector,target){return(target=target||new Vector3).x=vector.x*this.x,target.y=vector.y*this.y,target.z=vector.z*this.z,target}add(vector){return this.x+=vector.x,this.y+=vector.y,this.z+=vector.z,this}negate(target){return(target=target||new Vector3).x=-this.x,target.y=-this.y,target.z=-this.z,target}lerp(vector,t=.5,target){target=target||new Vector3;const x=this.x,y=this.y,z=this.z;return target.x=x+(vector.x-x)*t,target.y=y+(vector.y-y)*t,target.z=z+(vector.z-z)*t,target}dot(vector,target){target=target||new Vector3;const x=this.x,y=this.y,z=this.z;return x*vector.x+y*vector.y+z*vector.z}toArray(){return[this.x,this.y,this.z]}toObject(){return{x:this.x,y:this.y,z:this.z}}toString(){return`(${this.x}, ${this.y}, ${this.z})`}normalize(target){target=target||new Vector3;const x=this.x,y=this.y,z=this.z,len=Math.sqrt(x*x+y*y+z*z);return len>0&&(target.x=x/len,target.y=y/len,target.z=z/len),target}subtract(vector,target){return(target=target||new Vector3).x=this.x-vector.x,target.y=this.y-vector.y,target.z=this.z-vector.z,target}cross(vector,target){target=target||new Vector3;const vx=vector.x,vy=vector.y,vz=vector.z,x=this.x,y=this.y,z=this.z;return target.x=y*vz-z*vy,target.y=z*vx-x*vz,target.z=x*vy-y*vx,target}equals(other){return this.x===other.x&&this.y===other.y&&this.z===other.z}rotateByAngle(axis,angle,target){target=target||new Vector3,axis=axis.normalize();const cos=Math.cos(angle),sin=Math.sin(angle),rotatedNormal=this.scale(cos).add(axis.cross(this.normal).scale(sin)).add(axis.scale(axis.dot(this.normal)*(1-cos)));return target.copy(rotatedNormal.normalize()),target}quaternion(target){return(target=target||new Quaternion).set(this.x,this.y,this.z,0).normalize(),target}rotateByQuaternion(quaternion,target){target=target||new Vector3;const vectorQuat=new Quaternion(this.x,this.y,this.z,0),inverseQuat=quaternion.clone().invert(),rotatedQuat=quaternion.clone().multiply(vectorQuat).multiply(inverseQuat);return new Vector3(rotatedQuat.x,rotatedQuat.y,rotatedQuat.z)}rotateByVector(other,target){target=target||new Vector3;const thisNormalized=this.clone().normalize(),otherNormalized=other.clone().normalize(),axis=thisNormalized.cross(otherNormalized),angle=Math.acos(thisNormalized.dot(otherNormalized)),quaternion=new Quaternion(axis.x,axis.y,axis.z,Math.cos(angle/2));return quaternion.normalize(),quaternion.rotateVector(thisNormalized,target)}getDifference(other){const normalized1=this.clone().normalize(),normalized2=other.clone().normalize(),axis=normalized1.cross(normalized2),angle=Math.acos(normalized1.dot(normalized2)),quaternion=new Quaternion(axis.x,axis.y,axis.z,Math.cos(angle/2));return quaternion.normalize(),quaternion}test(){const vector1=new Vector3(1,0,0),vector2=new Vector3(0,1,0);vector1=vector1.rotateByVector(vector2),console.assert(0===vector1.x&&0===vector1.y&&1===vector1.z),console.assert(0===vector2.x&&0===vector2.y&&1===vector2.z)}}export{Vector2,Vector3};